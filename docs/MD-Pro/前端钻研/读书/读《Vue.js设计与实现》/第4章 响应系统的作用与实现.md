# 响应系统的作用与实现

## 响应式数据与副作用函数

- 响应式数据：对属性读取进行拦截做track操作，捕获执行的副作用函数；对属性设置进行拦截做trigger操作，触发捕获的副作用函数

- 副作用函数：即依赖了响应式数据的函数，数据的变化会让副作用函数重新执行

## 响应式数据的基本实现

- 读取数据属性=>捕获副作用
- 设置数据属性=>触发副作用

## 设计一个完善的响应系统

- bucket：使用`WeakMap`+`Map`设计了数据与副作用的关系桶
- effect：用于创建副作用函数与响应式数据的联系
- track：用于在数据属性读取时捕获执行中的副作用并建立联系
- trigger：用于在数据属性改变时重新执行联系的副作用

## 分支切换与cleanup

- 分支切换：副作用的分支结构中不会进入的分支若存在响应式数据，则该数据的改变不应该让副作用重新执行
- cleanup：让副作用每次执行前，清除它依赖的响应式数据对它的联系，然后在执行时重新建立联系，就不会有冗余无用的依赖触发响应式了

## 嵌套effect与effect栈

- 嵌套effect时，要注意执行中副作用的值，让effect栈在副作用执行前，先设置副作用并将其压入栈，执行后让其弹出，并设置重新设置执行中的副作用

## 避免无限递归循环

- 若副作用的执行会触发数据的（读取与）设置，则会无限触发副作用的执行
  - 解决方式：若执行副作用在数据的副作用集合中，则集合中跳过该副作用的执行

## 调度执行

- 调度执行：即控制副作用执行的时机、次数、方式，设置scheduler配置，在trigger中拦截副作用并让副作用可以按照特定的方式执行
- 将副作用通过调度器置入微任务队列中，实现控制执行时机与任务去重

## 计算属性computed与lazy

- lazy懒执行，即让副作用不立即执行，而是后续进行手动执行
- 计算属性：值由getter函数获取，当getter依赖改变时，拦截依赖的trigger来执行计算属性联系的副作用
  - 计算属性的缓存：当getter依赖未改变时，读取缓存数据值；若getter依赖发生改变，则重新执行副作用getter获取新属性值

## watch的实现原理

- 当监视数据发生改变时，执行watch的回调函数的封装job函数，并传入oldValue与newValue

## 立即执行的watch与回调执行时机

- immediate：job函数立即执行一次
- 通过flush选项将job添加进微任务队列中，控制其执行时机

## 过期的副作用

- 竞态问题：即两个先后执行的副作用为异步行为，但无法确定哪个先执行完，可能会导致第一次执行的结果覆盖第二次的结果
  - 解决方式：为watch传入onInvalidate参入，让回调可以选择如何处理过期副作用，在新的副作用执行前会先将onInvalidate的回调执行来解决过期副作用，进而以最后的副作用结果为准
